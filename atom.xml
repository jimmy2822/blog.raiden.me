<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>硬底居米的部落格 | The Blog Of Indie Jimmy</title>
  
  <subtitle>硬底居米 Indie Jimmy</subtitle>
  <link href="https://blog.raiden.me/atom.xml" rel="self"/>
  
  <link href="https://blog.raiden.me/"/>
  <updated>2021-03-15T03:48:44.700Z</updated>
  <id>https://blog.raiden.me/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netflix Chosen - Rhythm + Flow 嘻哈王</title>
    <link href="https://blog.raiden.me/2019/10/25/netflix-chosen-rhythm-and-flow/"/>
    <id>https://blog.raiden.me/2019/10/25/netflix-chosen-rhythm-and-flow/</id>
    <published>2019-10-24T17:00:36.000Z</published>
    <updated>2021-03-15T03:48:44.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="影集資訊"><a href="#影集資訊" class="headerlink" title="影集資訊"></a>影集資訊</h1><hr><ul><li>名稱：Rhythm + Flow 嘻哈王</li><li>類型：選秀節目</li><li>日期：2019</li><li>平台：Netflix</li><li>元素：嘻哈、饒舌、選秀節目</li></ul><h1 id="沙發上的馬鈴薯"><a href="#沙發上的馬鈴薯" class="headerlink" title="沙發上的馬鈴薯"></a>沙發上的馬鈴薯</h1><hr><p>身為沙發上的馬鈴薯(couch potato)，當平日下班打卡回家後，坐在沙發上打開今日晚餐配著飯的不是左右手(喂～），也不是你的水管(Youtube)，而是害傳統錄影帶出租店倒光的 Netflix。身為《中國有嘻哈》到《中國新說唱》的忠實觀眾。你也會跟我一樣，一邊看著節目一邊開始 freestyle 起來嗎？我想答案可能是不會吧～但是當我把華語饒舌選秀節目都刷過一遍後，隨之而來的不是我饒舌功力的進步，而是一陣失落感。怎麼又沒節目看了呢？這可能是著迷於次文化的一種悲哀吧。畢竟非主流的市場就代表著小眾，而小眾的東西代表喜歡的人自然就少了很多，沒人看怎麼會有收視率，要怎麼賣廣告？沒有了廣告意味著沒有更多的資源繼續做節目啦～如此的現實循環之下，節目精彩、爆紅才會有活下去的希望。生存是不是很難呢？特別是在這個人們的選擇愈來愈多，競爭愈演愈烈的時代下。（想混口飯吃還真難呢⋯⋯）</p><h1 id="嘻哈王？"><a href="#嘻哈王？" class="headerlink" title="嘻哈王？"></a>嘻哈王？</h1><hr><p>對，剛剛的馬鈴薯有一晚又繼續打開 Netflix，直到看見了大數據的奇蹟。它推薦了我一個算新的節目《Rhythm + Flow》中文譯作《嘻哈王》當然我的腦袋會自動過濾那看起來很突兀的中文。這個推薦對於喜愛饒舌文化的我來說，根本就像看見了毒品一樣無法抗拒，更不用說節目請來的評審各個都是大咖中的大咖！如下圖：</p><p><img src="https://i.imgur.com/KmbKTtR.jpg" alt="The Judges"></p><p>從左邊數來分別是 T.I.、Cardi B、Chance The Rapper ，不過說真的，我對於國外的嘻哈藝人也沒有很了解。但是當看完整季節目後(Google 後)才了解到他們的專業。而且大部分是透過他們在比賽中給予的講評，才對饒舌和商業和全能藝人之間的關係有了更高一層的理解。當你整季看完後，會了解到這個節目和《中國新說唱》的節目整體差異性在哪，又或者說美國人製作節目和中國人製作節目的差異性在哪。更不用說當中國人學習美國次文化，和次文化本身的發源地之間的差異性。舉個例子：東方人嘴巴講出來的尼哥，就和正統的尼哥最巴說出來的尼哥感覺就是不一樣！我是指正真的黑人和亞洲人稱呼黑人的感覺差異啦⋯⋯</p><h1 id="紐約、亞特蘭大、芝加哥：城市的不同面貌"><a href="#紐約、亞特蘭大、芝加哥：城市的不同面貌" class="headerlink" title="紐約、亞特蘭大、芝加哥：城市的不同面貌"></a>紐約、亞特蘭大、芝加哥：城市的不同面貌</h1><hr><p>老實說，筆者還真的沒去過美國。但是透過節目的了解，我大概能知道身為北投區石牌人。我們住在俗稱天龍人的皇城，天母旁邊的差異。就像紐約最著名的兩個區：皇后區和曼哈頓的差距。</p><p>路人甲：你不是說沒去過美國？<br>路人乙：是不會去 Google 和 Wiki 喔？<br>路人甲：可以～<br>路人乙：客氣～客氣～別逼我 diss 你！<br>路人甲：（怕</p><p>天母是眾所皆知的富人豪宅的集中地，石牌在相較之下就顯得沒那麼富裕就是了，如果說要數據論証的話，我想我們可以從房價的地區中位數來看應該就會比較準確但我們在這裡要討論的不是中產階級和富人階級之間的差異。我們了解的是在美國也有很多城市，城市之間的富裕程度會體現在人民的生活上。而這樣的物質差距，也會孕育出不同的居民。自然而然的環境影響的人也會體現在創作的差異上。</p><h1 id="饒舌歌手的背後故事"><a href="#饒舌歌手的背後故事" class="headerlink" title="饒舌歌手的背後故事"></a>饒舌歌手的背後故事</h1><hr><p>在一個海選的競賽節目中，如何讓節目精彩呢？我在這個節目中看見的手法是藉由每一位選手背後的故事來添增節目的豐富層度。前面所提到的城市間差異，在這個角度中，正是讓節目如此精彩的一大亮點。我很驚訝的是這一季的選手中，有非常大的比例選手從小就是由單親扶養。甚至有很多人是從小身長在毒品、幫派、槍枝的生活中長大的。也有人的家庭從小父親就會酗酒家暴，諸如此類的不幸，最終他們都找到了同樣的出口，饒舌，當作心靈上的出口。這正是筆者喜愛音樂的重要原因之一。（未完待續⋯⋯）</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;影集資訊&quot;&gt;&lt;a href=&quot;#影集資訊&quot; class=&quot;headerlink&quot; title=&quot;影集資訊&quot;&gt;&lt;/a&gt;影集資訊&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;名稱：Rhythm + Flow 嘻哈王&lt;/li&gt;
&lt;li&gt;類型：選秀節目&lt;/li&gt;
&lt;li&gt;日期：2019&lt;/li&gt;
&lt;li&gt;平台：Netflix&lt;/li&gt;
&lt;li&gt;元素：嘻哈、饒舌、選秀節目&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;沙發上的馬鈴薯&quot;&gt;&lt;a href=&quot;#沙發上的馬鈴薯&quot; class=&quot;headerlink&quot; title=&quot;沙發上的馬鈴薯&quot;&gt;&lt;/a&gt;沙發上的馬鈴薯&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;身為沙發上的馬鈴薯(couch potato)，當平日下班打卡回家後，坐在沙發上打開今日晚餐配著飯的不是左右手(喂～），也不是你的水管(Youtube)，而是害傳統錄影帶出租店倒光的 Netflix。身為《中國有嘻哈》到《中國新說唱》的忠實觀眾。你也會跟我一樣，一邊看著節目一邊開始 freestyle 起來嗎？我想答案可能是不會吧～但是當我把華語饒舌選秀節目都刷過一遍後，隨之而來的不是我饒舌功力的進步，而是一陣失落感。怎麼又沒節目看了呢？這可能是著迷於次文化的一種悲哀吧。畢竟非主流的市場就代表著小眾，而小眾的東西代表喜歡的人自然就少了很多，沒人看怎麼會有收視率，要怎麼賣廣告？沒有了廣告意味著沒有更多的資源繼續做節目啦～如此的現實循環之下，節目精彩、爆紅才會有活下去的希望。生存是不是很難呢？特別是在這個人們的選擇愈來愈多，競爭愈演愈烈的時代下。（想混口飯吃還真難呢⋯⋯）&lt;/p&gt;
&lt;h1 id=&quot;嘻哈王？&quot;&gt;&lt;a href=&quot;#嘻哈王？&quot; class=&quot;headerlink&quot; title=&quot;嘻哈王？&quot;&gt;&lt;/a&gt;嘻哈王？&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;對，剛剛的馬鈴薯有一晚又繼續打開 Netflix，直到看見了大數據的奇蹟。它推薦了我一個算新的節目《Rhythm + Flow》中文譯作《嘻哈王》當然我的腦袋會自動過濾那看起來很突兀的中文。這個推薦對於喜愛饒舌文化的我來說，根本就像看見了毒品一樣無法抗拒，更不用說節目請來的評審各個都是大咖中的大咖！如下圖：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/KmbKTtR.jpg&quot; alt=&quot;The Judges&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="沙發上的居米" scheme="https://blog.raiden.me/categories/%E6%B2%99%E7%99%BC%E4%B8%8A%E7%9A%84%E5%B1%85%E7%B1%B3/"/>
    
    
    <category term="Netflix" scheme="https://blog.raiden.me/tags/Netflix/"/>
    
    <category term="饒舌" scheme="https://blog.raiden.me/tags/%E9%A5%92%E8%88%8C/"/>
    
    <category term="節目心得" scheme="https://blog.raiden.me/tags/%E7%AF%80%E7%9B%AE%E5%BF%83%E5%BE%97/"/>
    
    <category term="生活" scheme="https://blog.raiden.me/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 中的設計模式－裝飾模式 Decorator</title>
    <link href="https://blog.raiden.me/2019/10/15/design-pattern-decorator/"/>
    <id>https://blog.raiden.me/2019/10/15/design-pattern-decorator/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2021-03-15T03:48:44.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><hr><ul><li>裝飾模式允許我們在沒有影響同類的物件下對物件改變其行為</li><li>裝飾模式是替代創建子類別的好方法</li></ul><h2 id="情境探討"><a href="#情境探討" class="headerlink" title="情境探討"></a>情境探討</h2><hr><p>假設我們有一台車的商品，售價為一百。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">car = <span class="title class_">Car</span>.new</span><br><span class="line"></span><br><span class="line">puts car.price</span><br></pre></td></tr></table></figure><p>我們現在需要為車子新增零件。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CarWithLight</span> &lt; <span class="title class_ inherited__">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="number">120</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>現在有一台跑車掛滿零件，很貴。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportCar</span> &lt; <span class="title class_ inherited__">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="number">250</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>現在我們因為車子多加零件所以要變更價格，但是我們花了許多 class 去做這件事情。如果還有更多種類的車子，我們會遇上更多麻煩。</p><p>如果我們考慮用動態的 module 去延伸呢？</p><h2 id="Extending-dynamically-with-modules"><a href="#Extending-dynamically-with-modules" class="headerlink" title="Extending dynamically with modules"></a>Extending dynamically with modules</h2><hr><p>為了簡化我們的程式碼，我們使用模組動態新增行為到車子上。讓我們把新的車子零件改寫為模組。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="title class_">CarWithLight</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="variable language_">super</span> + <span class="number">20</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> <span class="title class_">SportCar</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="variable language_">super</span> + <span class="number">150</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>現在我們用 Ruby 的方法 <code>extend</code> 將原本的 <code>Car</code> 做延伸。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="title class_">Car</span>.new               =&gt; <span class="comment"># price = 100</span></span><br><span class="line">car.<span class="keyword">extend</span>(<span class="title class_">CarWithLight</span>)    =&gt; <span class="comment"># price = 120</span></span><br><span class="line">car.<span class="keyword">extend</span>(<span class="title class_">SportCar</span>)        =&gt; <span class="comment"># price = 270</span></span><br></pre></td></tr></table></figure><p>在使用 module 的方式下，我們不必再新增多餘的子類別去繼承 <code>Car</code>，寫法上又比繼承的方式簡潔不少。</p><p>但是隨著 module 化後，如先前舉例我們使用 <code>extend</code> 來獲得不同車種零件的價格加乘。但是接著我們會發現我們想要對同一個物件的價格加乘兩次時，<code>module</code> 不允許我們這麼做。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="title class_">Car</span>.new               =&gt; <span class="comment"># price = 100</span></span><br><span class="line">car.<span class="keyword">extend</span>(<span class="title class_">CarWithLight</span>)    =&gt; <span class="comment"># price = 120</span></span><br><span class="line">car.<span class="keyword">extend</span>(<span class="title class_">CarWithLight</span>)    =&gt; <span class="comment"># price = 120</span></span><br></pre></td></tr></table></figure><p>如上範例程式碼，當我們對同一個物件 <code>extend</code> 兩次，會發現第二次的執行不會對車子價格產生影響。這是因為 <code>extend</code> 在 Ruby 中實作機制不允許我們這樣使用。是時候尋找新的方法了。</p><h2 id="使用-Decorator-Pattern"><a href="#使用-Decorator-Pattern" class="headerlink" title="使用 Decorator Pattern"></a>使用 Decorator Pattern</h2><hr><p>如果我們想要對車子添加更多零件，我們可以把車子的零件以 <code>Decorator Object</code> 的形式實作它。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCarPart</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">car</span>)</span><br><span class="line">    <span class="variable">@car</span> = car</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="variable">@car</span>.price + <span class="number">25</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">car =  <span class="title class_">Car</span>.new</span><br><span class="line">normal_car = <span class="title class_">AddCarPart</span>.new(car)</span><br><span class="line">sport_car = <span class="title class_">AddCarPart</span>.new(normal_car)</span><br><span class="line"></span><br><span class="line">puts car.price          <span class="comment"># =&gt; 100</span></span><br><span class="line">puts normal_car.price   <span class="comment"># =&gt; 125</span></span><br><span class="line">puts sport_car.price    <span class="comment"># =&gt; 150</span></span><br></pre></td></tr></table></figure><p>當我們使用 Decorator Object 時，我們期待這個 Object 會傳入 <code>Car</code> 類別進來，並且對該類別的實體進行價格的增減。這樣的使用情境下就會符合我們預期中的行為，也可以解決 <code>Module</code> 被多次 <code>extend</code> 導致無法正常作用的窘境。</p><h2 id="Delegate-委派"><a href="#Delegate-委派" class="headerlink" title="Delegate 委派"></a>Delegate 委派</h2><hr><p>當我們的裝飾物件類別的實體需要新增一個實例方法時，我們會遇上一些麻煩。例如先前範例中的 <code>Car</code> 類別，如果 <code>Car</code> 新增一個 <code>#turbo</code> 方法呢？已經透過裝飾物件 <code>AddCarPart</code> 變更行為的實體便不會擁有新的方法 <code>#turbo</code> 了。像這樣的情境我們可以使用委派（Delegate）的方式來解決像這樣的問題。範例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="number">100</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarDelegator</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts price</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCarPart</span> &lt; <span class="title class_ inherited__">CarDelegator</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">car</span>)</span><br><span class="line">    <span class="variable">@car</span> = car</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">price</span></span><br><span class="line">    <span class="variable">@car</span>.price + <span class="number">25</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">car =  <span class="title class_">Car</span>.new</span><br><span class="line">normal_car = <span class="title class_">AddCarPart</span>.new(car)</span><br><span class="line">sport_car = <span class="title class_">AddCarPart</span>.new(normal_car)</span><br><span class="line"></span><br><span class="line">normal_car.info   <span class="comment"># =&gt; 125</span></span><br><span class="line">sport_car.info    <span class="comment"># =&gt; 150</span></span><br></pre></td></tr></table></figure><p>我們在這段範例中為 <code>Car</code> 類別實作了一個 <code>Delegator</code>，並且將 <code>AddCarPart</code> 繼承它。如此一來，我們在委派的類別中成功為所有需要通過裝飾類別的物件統一加入某個方法。假設在該裝飾物件中，同樣的方法想要有不同的行為，我們也可以覆寫它並保有彈性。</p><h2 id="關於學習設計模式"><a href="#關於學習設計模式" class="headerlink" title="關於學習設計模式"></a>關於學習設計模式</h2><hr><p>所謂的設計模式（Design Pattern）是一種經驗法則的產物。在各種程式語言中幾乎都可以利用語言的特性去實作設計模式。為什麼我們要學習設計模式呢？因為前人所累積的智慧，在應對特定的情境上找出常用的解法。這樣一來新進的工程師在面臨結構相似的問題時，就可以參考各種設計模式並瞭解其中的優劣，進而幫助自己釐清問題的本質。</p><p>這是部落格第一篇描寫關於設計模式的文章，聽說設計模式一共有二十來種呢⋯⋯期待在接下來的文章分享中，我們能繼續探索並分享設計模式的學習心得。一起邁向偉大的航道吧！（充滿臭蟲的海域？</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;裝飾模式允許我們在沒有影響同類的物件下對物件改變其行為&lt;/li&gt;
&lt;li&gt;裝飾模式是替代創建子類別的好方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;情境探討&quot;&gt;&lt;a href=&quot;#情境探討&quot; class=&quot;headerlink&quot; title=&quot;情境探討&quot;&gt;&lt;/a&gt;情境探討&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;假設我們有一台車的商品，售價為一百。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Car&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;price&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;car = &lt;span class=&quot;title class_&quot;&gt;Car&lt;/span&gt;.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts car.price&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我們現在需要為車子新增零件。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;CarWithLight&lt;/span&gt; &amp;lt; &lt;span class=&quot;title class_ inherited__&quot;&gt;Car&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;price&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;number&quot;&gt;120&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;現在有一台跑車掛滿零件，很貴。&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby Design Pattern 設計模式" scheme="https://blog.raiden.me/categories/Ruby-Design-Pattern-%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Ruby" scheme="https://blog.raiden.me/tags/Ruby/"/>
    
    <category term="Object-Oriented" scheme="https://blog.raiden.me/tags/Object-Oriented/"/>
    
    <category term="Design-Pattern" scheme="https://blog.raiden.me/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>想找到脫離新手村的方向？ 讓 Ruby 中的物件導向基礎為你引路！</title>
    <link href="https://blog.raiden.me/2019/08/24/object-oriented-in-ruby/"/>
    <id>https://blog.raiden.me/2019/08/24/object-oriented-in-ruby/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2021-03-15T03:48:44.698Z</updated>
    
    <content type="html"><![CDATA[<p>還記得一開始自學程式語言時，大家一定或多或少都聽過一個名詞 <code>物件導向</code>。然後身為程式新手和非程式相關科系畢業的你也許會開始 Google 它到底是什麼意思，然後你會在 <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">維基百科</a> 上查到諸如此類的解釋：</p><blockquote><p>物件導向程式設計（英語：Object-oriented programming，縮寫：OOP）是種具有物件概念的程式編程典範，同時也是一種程式開發的抽象方針。它可能包含資料、屬性、程式碼與方法。物件則指的是類別的實體。它將物件作為程式的基本單元，將程式和資料封裝其中，以提高軟體的重用性、靈活性和擴充性，物件裡的程式可以存取及經常修改物件相關連的資料。在物件導向程式編程裡，電腦程式會被設計成彼此相關的物件。</p></blockquote><p>當下看完名詞解釋，如果你和筆者一樣只是個普通人的話應該根據名詞解釋還是無法了解一個抽象的概念，然後可能因為你強盛的好奇心，會繼續在網路上搜尋更多的文章來理解這樣抽象的概念，但有可能你會發現閱讀更多文章後仍然似懂非懂，不要擔心這是屬於正常的現象。</p><h2 id="找到方向"><a href="#找到方向" class="headerlink" title="找到方向"></a>找到方向</h2><hr><p>上述所描寫的正是筆者個人學習上的經歷，看了些許文章後，仍然覺得少了點什麼才能對整體抽象的理論有更進一步的理解。直到閱讀了 <code>Practical Object-Oriented Design: An Agile Primer Using Ruby</code> 才發現作者 <a href="https://www.sandimetz.com/">Sandi Metz</a> 很懂得如何引導新手走入物件導向的大門。例如談論到物件導向時一定會提到的幾個重要原則：<code>SOLID</code>（<code>單一功能</code>、<code>開閉原則</code>、<code>李氏替換</code>、<code>介面隔離</code>、<code>依賴反轉</code>）當你看過這些原則後對於實際開發上該怎麼應用上，根據筆者個人的學習經驗似乎只會產生更多的疑問。但作者似乎知道與其講那些理論，不如透過探討實際的程式碼由淺入深的方式一步一步告訴你如果同樣的程式碼，採用物件導向的方式撰寫程式碼會有什麼優缺點？如果不使用物件導向的方式去寫可能會造成後續維護程式碼上困難？筆者看完那本書後終於對物件導向有了更深一層的概念，它也提供了思考程式碼「為什麼要這樣寫會更好？」的方向，而不僅僅是停在「把程式碼寫出來會動就好⋯⋯」的層面上。</p><p>接下來將分享書中部分的概念，去探討如何運用技巧去撰寫出容易維護的程式碼。</p><h2 id="管理相依性-Manage-Dependencies"><a href="#管理相依性-Manage-Dependencies" class="headerlink" title="管理相依性 Manage Dependencies"></a>管理相依性 Manage Dependencies</h2><hr><p>在物件導向的程式世界中，物件會有所謂 <code>相依性</code> 的問題，什麼是相依性呢？我們舉現實生活中的車子來理解這個抽象概念。車子是一種交通工具對吧？在 <code>Ruby</code> 中車子將可能會是車子這個類別中的一個實體物件，它的行為是進行移動。那車子為什麼可以移動的呢？車子是需要靠輪子來移動的，我們也可以說車子依賴輪子來進行移動，沒有輪子的車子可能哪也去不了，所以車子對輪子產生了很高的相依性。</p><p>在物件導向的世界中，我們對程式類別和物件相互依賴的程度高低稱為 <a href="https://zh.wikipedia.org/wiki/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8">耦合性</a>。耦合性愈高的程式理論上來講會愈難維護，這點可以想像我們先前舉例的車子。假設有一款特殊類別的車子，輪子的構造和一般輪子的構造不一樣，是所謂一體成型的構造。也就是說它的輪子不容易替換，那這輛特殊的車子對於這種特別設計的輪子就會有較高的依賴性。就算真的壞了也沒辦法像其他一般車子一樣快速找到同規格的零件進行替換，當我們這樣設計一台車子的時候就像在設計程式中的類別與方法。我們有沒有遵循物件導向的思維去設計程式，在未來專案的開發與維護時就會產生成本上顯著的差異。</p><p>接下來我們將透過程式碼的範例介紹 <code>Ruby</code> 程式語言特性所衍生出來降低程式碼之間的耦合度與管理相依性的技巧。</p><h2 id="移除參數順序的相依性-Remove-Argument-Order-Dependencies"><a href="#移除參數順序的相依性-Remove-Argument-Order-Dependencies" class="headerlink" title="移除參數順序的相依性 Remove Argument-Order Dependencies"></a>移除參數順序的相依性 Remove Argument-Order Dependencies</h2><hr><p>在 <code>Ruby</code> 中，當我們要定義一個方法時通常會像接下來的例子一樣定義它：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">color, type, wheels</span>)</span><br><span class="line">    <span class="variable">@color</span> = color</span><br><span class="line">    <span class="variable">@type</span> = type</span><br><span class="line">    <span class="variable">@wheels</span> = wheels</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts <span class="string">&quot;這輛車子是<span class="subst">#&#123;<span class="variable">@color</span>&#125;</span>色的，類型為<span class="subst">#&#123;<span class="variable">@type</span>&#125;</span>，輪子有<span class="subst">#&#123;<span class="variable">@wheels</span>&#125;</span>個。&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sport_car = <span class="title class_">Car</span>.new(<span class="string">&#x27;黃&#x27;</span>, <span class="string">&#x27;跑車&#x27;</span>, <span class="number">4</span>)</span><br><span class="line">sport_car.info <span class="comment"># =&gt; 這輛車子是黃色的，類型為跑車，輪子有4個。</span></span><br></pre></td></tr></table></figure><p>在這段範例中，我們定義了 <code>Car</code> 這個類別(Class)，然後我們在類別中透過定義初始化方法(Initialize)規定了方法需要傳入三個參數(Parameter)，並且在 <code>Car.new</code> 實例化類別時需要<code>依序</code>將參數傳入。最後再定義了一個方法 <code>info</code> 去顯示這輛車子的資訊(<code>color</code>, <code>type</code>, <code>wheels</code>)。</p><p>當我們定義好 <code>Car</code> 這個類別並且有一天我們的同事需要使用這個車子類別去做一些事情的時候，你可能會需要寫一份文件就像 <a href="https://ruby-doc.org/core-2.6.3/">Ruby Doc</a> 一樣解釋這個車子類別在實例化時需要依照順序傳入哪些參數。在這個簡單的例子中你可能會覺得，才三個參數會是有多難記？但是你有一天可能會面臨需要建立一個方法擁有七個參數以上要傳呢？你能確保每一個參數的順序你都記得嗎？萬一傳錯順序了程式可能會產生不可預期的錯誤。這時候我們就可以運用 <code>Ruby</code> 的一個特性來解決問題，它就是<a href="https://ruby-doc.org/core-2.6.3/Hash.html">雜湊</a>(Hash)！</p><p>在 <code>Ruby</code> 的世界中，雜湊是沒有順序性的，它關注的只有一對成雙 <code>Key</code> 和 <code>Value</code> 的組合，只要對 <code>Hash</code> 提供正確的 <code>Key</code> 就能取出那把 <code>Key</code> 所對應的值。所以在知名的網頁框架 <a href="https://rails.ruby.tw/getting_started.html">Ruby On Rails</a> 的方法中可以大量發現使用 <code>Hash</code> 的存在。現在就讓我們利用 <code>Hash</code> 來把剛剛的範例改寫如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info</span>)</span><br><span class="line">    <span class="variable">@color</span> = info[<span class="symbol">:color</span>]</span><br><span class="line">    <span class="variable">@type</span> = info[<span class="symbol">:type</span>]</span><br><span class="line">    <span class="variable">@wheels</span> = info[<span class="symbol">:wheels</span>] |<span class="params"></span>| <span class="number">4</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts <span class="string">&quot;這輛車子是<span class="subst">#&#123;<span class="variable">@color</span>&#125;</span>色的，類型為<span class="subst">#&#123;<span class="variable">@type</span>&#125;</span>，輪子有<span class="subst">#&#123;<span class="variable">@wheels</span>&#125;</span>個。&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sport_car = <span class="title class_">Car</span>.new(<span class="symbol">type:</span> <span class="string">&#x27;跑車&#x27;</span>, <span class="symbol">color:</span> <span class="string">&#x27;橘&#x27;</span>, <span class="symbol">wheels:</span> <span class="number">4</span>)</span><br><span class="line">sport_car.info      <span class="comment"># =&gt; 這輛車子是橘色的，類型為跑車，輪子有4個。</span></span><br><span class="line"></span><br><span class="line">compact_car = <span class="title class_">Car</span>.new(<span class="symbol">color:</span> <span class="string">&#x27;黑&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;房車&#x27;</span>)</span><br><span class="line">compact_car.info    <span class="comment"># =&gt; 這輛車子是黑色的，類型為房車，輪子有4個。</span></span><br></pre></td></tr></table></figure><p>還記得我們在前一個例子中，實例化方法需要依照順序傳入的三個參數嗎？利用 <code>Hash</code> 改寫後，現在我們的 <code>initialize</code> 的參數部分只規定了一個 <code>info</code>，實際上這個 <code>info</code> 代表是一個 <code>Hash</code>。我們現在從 <code>info</code> 取出三個 <code>Key</code> 分別是 <code>:color</code>, <code>:type</code>, <code>:wheels</code> 所對應得值，並將它們存入實體變數 <code>@color</code>, <code>@type</code>, <code>@wheels</code> 當中給 <code>info</code> 方法顯示資訊用。</p><p>這樣一來當我們將參數改為傳入一個 <code>Hash</code> 後，我們已經移除提供參數時會產生參數傳入對順序相依的問題，這樣就可以降低因為順序錯誤導致程式出錯的機率。再者因為當我們對 <code>Hash</code> 提供 <code>Key</code> 要取出對應的值為 <code>nil</code> 時，我們可以再利用一個小技巧讓值為 <code>nil</code> 時自動帶入預設的數值。也就是這個範例中的這段程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@wheels</span> = info[<span class="symbol">:wheels</span>] |<span class="params"></span>| <span class="number">4</span></span><br></pre></td></tr></table></figure><p>當我們對 <code>info</code> 取出輪子數量為 <code>nil</code> 時（也就是使用者沒有傳入 <code>wheels: 輪子數量</code>)，這時因為 <code>info[:wheels] || 4</code> 前者為 <code>nil</code> 時會回傳後者的特性，我們實作了當使用者沒有提供該參數時自動帶入 <code>4</code> 的預設值。所以範例中的 <code>compact_car</code> 在實例化過程中如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compact_car = <span class="title class_">Car</span>.new(<span class="symbol">color:</span> <span class="string">&#x27;黑&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;房車&#x27;</span>)</span><br><span class="line">compact_car.info    <span class="comment"># =&gt; 這輛車子是黑色的，類型為房車，輪子有4個。</span></span><br></pre></td></tr></table></figure><p>我並沒有傳入 <code>wheels</code> 的值，但在執行 <code>compact_car.info</code> 時仍然能自動帶入輪子數量的預設值並印出 <code>這輛車子是黑色的，類型為房車，輪子有4個。</code></p><h2 id="孤立相依性-Isolate-Dependencies"><a href="#孤立相依性-Isolate-Dependencies" class="headerlink" title="孤立相依性 Isolate Dependencies"></a>孤立相依性 Isolate Dependencies</h2><hr><p>當我們在開發專案時，你終究會遇到需在自身類別中使用其它類別所實例化的物件來做一些事情。但每當你在自身類別中引用其它類別時，實際上也是在對其它類別產生了相依性，並且提高了這個類別對其他程式碼的耦合度，這樣的情況並不是我們所樂見的。當我們必須對其它類別產生相依性且無可避免的時候呢？我們該怎麼處理類似的情況呢？這時候我們可以選擇孤立其它類別在自身類別中。接下來我們將使用實例來探討該如何處理類似的情況。</p><p>繼續我們先前的車子範例，如果我們要繼續打造這台車子，但是輪子需要乘載更多的資訊量呢？是時候考慮將輪子獨立出來自成一類來處理相關的資訊了。我們先將程式範例改寫為如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:color</span>, <span class="symbol">:wheels</span>, <span class="symbol">:type</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">    <span class="variable">@name</span> = info[<span class="symbol">:name</span>] |<span class="params"></span>| <span class="string">&#x27;未命名&#x27;</span></span><br><span class="line">    <span class="variable">@color</span>  = info[<span class="symbol">:color</span>]  |<span class="params"></span>| <span class="string">&#x27;藍&#x27;</span></span><br><span class="line">    <span class="variable">@type</span>   = info[<span class="symbol">:type</span>]   |<span class="params"></span>| <span class="string">&#x27;房車&#x27;</span></span><br><span class="line">    <span class="variable">@wheels</span> = info[<span class="symbol">:wheels</span>] |<span class="params"></span>| <span class="title class_">Wheels</span>.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;name&#125;</span>，這輛車子是<span class="subst">#&#123;<span class="variable">@color</span>&#125;</span>色的，類型為<span class="subst">#&#123;<span class="variable">@type</span>&#125;</span>，輪子有<span class="subst">#&#123;<span class="variable">@wheels</span>.quantity&#125;</span>個。&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheels</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:color</span>, <span class="symbol">:quantity</span>, <span class="symbol">:type</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">    <span class="variable">@color</span> = info[<span class="symbol">:color</span>] |<span class="params"></span>| <span class="string">&#x27;黑&#x27;</span></span><br><span class="line">    <span class="variable">@quantity</span> = info[<span class="symbol">:quantity</span>] |<span class="params"></span>| <span class="number">4</span></span><br><span class="line">    <span class="variable">@type</span> = info[<span class="symbol">:type</span>] |<span class="params"></span>| <span class="string">&#x27;道路&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts <span class="string">&quot;這台車的輪胎規格為<span class="subst">#&#123;<span class="variable">@type</span>&#125;</span>胎，顏色為<span class="subst">#&#123;<span class="variable">@color</span>&#125;</span>色，共有<span class="subst">#&#123;<span class="variable">@quantity</span>&#125;</span>個輪胎。&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">compact_car = <span class="title class_">Car</span>.new(<span class="symbol">name:</span> <span class="string">&#x27;發財車&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;貨車&#x27;</span>)</span><br><span class="line">compact_car.info          <span class="comment"># =&gt; 發財車，這輛車子是藍色的，類型為貨車，輪子有4個。</span></span><br><span class="line">compact_car.wheels.info   <span class="comment"># =&gt; 這台車的輪胎規格為道路胎，顏色為黑色，共有4個輪胎。</span></span><br><span class="line"></span><br><span class="line">super_car = <span class="title class_">Car</span>.new(<span class="symbol">name:</span> <span class="string">&#x27;佛拉利&#x27;</span>, <span class="symbol">color:</span> <span class="string">&#x27;紅&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;跑車&#x27;</span>,</span><br><span class="line"><span class="symbol">wheels:</span> <span class="title class_">Wheels</span>.new(<span class="symbol">color:</span> <span class="string">&#x27;銀&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;賽道&#x27;</span>))</span><br><span class="line">super_car.info            <span class="comment"># =&gt; 佛拉利，這輛車子是紅色的，類型為跑車，輪子有4個。</span></span><br><span class="line">super_car.wheels.info     <span class="comment"># =&gt; 這台車的輪胎規格為賽道胎，顏色為銀色，共有4個輪胎。</span></span><br></pre></td></tr></table></figure><p>當我們決定把 <code>Wheels</code> 獨立拆出來成為一個類別時，我們的 <code>Car</code> 類別很自然的會期待在初始化物件時接收一個 <code>Wheels</code> 類別的實體並存入一個實體變數當中，以待需要時取得 <code>Wheels</code> 的實體並使用它。我們所講述的正是這行程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@wheels</span> = info[<span class="symbol">:wheels</span>] |<span class="params"></span>| <span class="title class_">Wheels</span>.new</span><br></pre></td></tr></table></figure><p>還記得先前所講的嗎？當我們在自身類別中引用外部類別時，我們就對它產生了依賴性與提高了耦合度。我們現在對 <code>Wheels</code> 這個類別產生了依賴。現在來說你可能會想一切都在我的掌控之中因為 <code>Wheels</code> 這個類別是我所寫的，我很清楚它會如何運作。但是稍等一下⋯⋯假設今天的專案是多人協作的呢？<code>Wheels</code>這個類別是同事所寫的呢？你能確保在接下來的專案開時間下，<code>Wheels</code> 對這個類別呼叫 <code>Wheels.new</code> 所需要傳入的參數以及他所提供的 <a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3">API</a> <code>info</code> 不會有所變動嗎？它仍然是可靠的嗎？（謎之聲：那個誰誰誰？你幹嘛沒事去改動傳入的參數啦！？這樣害我程式整組壞光光惹 Q_Q，說好的可靠性呢？）</p><p>是的，我們的車子確實需要輪子來進行移動，這點無法分割的一部分我承認，但是總會有更好的方式來管理這種情況。那就是<code>孤立相依性</code>！既然我們沒辦法把它切割乾淨，那反其道而行，要依賴就要把關係處理好（更好維護的方式）所以因為前人的智慧，我們可以將這段程式碼修改為下列範例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:color</span>, <span class="symbol">:wheels</span>, <span class="symbol">:type</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">    <span class="variable">@name</span> = info[<span class="symbol">:name</span>] |<span class="params"></span>| <span class="string">&#x27;未命名&#x27;</span></span><br><span class="line">    <span class="variable">@color</span>  = info[<span class="symbol">:color</span>]  |<span class="params"></span>| <span class="string">&#x27;藍&#x27;</span></span><br><span class="line">    <span class="variable">@type</span>   = info[<span class="symbol">:type</span>]   |<span class="params"></span>| <span class="string">&#x27;房車&#x27;</span></span><br><span class="line">    external_wheels(wheels)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">external_wheels</span>(<span class="params">external_wheels</span>)</span><br><span class="line">    <span class="variable">@wheels</span> = external_wheels |<span class="params"></span>| <span class="title class_">Wheels</span>.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts <span class="string">&quot;<span class="subst">#&#123;name&#125;</span>，這輛車子是<span class="subst">#&#123;<span class="variable">@color</span>&#125;</span>色的，類型為<span class="subst">#&#123;<span class="variable">@type</span>&#125;</span>，輪子有<span class="subst">#&#123;<span class="variable">@wheels</span>.quantity&#125;</span>個。&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wheels</span></span><br><span class="line">  <span class="built_in">attr_reader</span> <span class="symbol">:color</span>, <span class="symbol">:quantity</span>, <span class="symbol">:type</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">info = &#123;&#125;</span>)</span><br><span class="line">    <span class="variable">@color</span> = info[<span class="symbol">:color</span>] |<span class="params"></span>| <span class="string">&#x27;黑&#x27;</span></span><br><span class="line">    <span class="variable">@quantity</span> = info[<span class="symbol">:quantity</span>] |<span class="params"></span>| <span class="number">4</span></span><br><span class="line">    <span class="variable">@type</span> = info[<span class="symbol">:type</span>] |<span class="params"></span>| <span class="string">&#x27;道路&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">info</span></span><br><span class="line">    puts <span class="string">&quot;這台車的輪胎規格為<span class="subst">#&#123;<span class="variable">@type</span>&#125;</span>胎，顏色為<span class="subst">#&#123;<span class="variable">@color</span>&#125;</span>色，共有<span class="subst">#&#123;<span class="variable">@quantity</span>&#125;</span>個輪胎。&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">compact_car = <span class="title class_">Car</span>.new(<span class="symbol">name:</span> <span class="string">&#x27;發財車&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;貨車&#x27;</span>)</span><br><span class="line">compact_car.info            <span class="comment"># =&gt; 發財車，這輛車子是藍色的，類型為貨車，輪子有4個。</span></span><br><span class="line">compact_car.wheels.info     <span class="comment"># =&gt; 這台車的輪胎規格為道路胎，顏色為黑色，共有4個輪胎。</span></span><br><span class="line"></span><br><span class="line">super_car = <span class="title class_">Car</span>.new(<span class="symbol">name:</span> <span class="string">&#x27;佛拉利&#x27;</span>, <span class="symbol">color:</span> <span class="string">&#x27;紅&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;跑車&#x27;</span>,</span><br><span class="line">                    <span class="symbol">wheels:</span> <span class="title class_">Wheels</span>.new(<span class="symbol">color:</span> <span class="string">&#x27;銀&#x27;</span>, <span class="symbol">type:</span> <span class="string">&#x27;賽道&#x27;</span>))</span><br><span class="line">super_car.info              <span class="comment"># =&gt; 佛拉利，這輛車子是紅色的，類型為跑車，輪子有4個。</span></span><br><span class="line">super_car.wheels.info       <span class="comment"># =&gt; 這台車的輪胎規格為賽道胎，顏色為銀色，共有4個輪胎。</span></span><br></pre></td></tr></table></figure><p>有發現差異了嗎？我們把在 <code>Car</code> 類別中的 <code>initialize</code> 方法中，我們把先前的：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@wheels</span> = info[<span class="symbol">:wheels</span>] |<span class="params"></span>| <span class="title class_">Wheels</span>.new</span><br></pre></td></tr></table></figure><p>改寫為：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">external_wheels(wheels)</span><br></pre></td></tr></table></figure><p>然後在 <code>Car</code> 類別中新增一個方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">external_wheels</span>(<span class="params">external_wheels</span>)</span><br><span class="line">  <span class="variable">@wheels</span> = external_wheels |<span class="params"></span>| <span class="title class_">Wheels</span>.new</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>為什麼要這樣寫呢？因為如剛剛我說，我們目的是要把引用外部類別 <code>Wheels</code> 抽離出來成一個獨立的方法。這樣對我們來說有什麼好處嗎？根據古人的智慧把外部類別隔離成一個方法有以下好處：</p><ol><li>當我們引用外部類別，獨立出來可以很明確的知道它是來自外部，是較為不可靠的。</li><li>當這個外部類別發生變動導致程式錯誤時，你可以很快找到是在某個隔離出來的方法之中，而不是從一堆程式碼中大海撈針。</li></ol><h2 id="小結-小傑（奇犽？"><a href="#小結-小傑（奇犽？" class="headerlink" title="小結 || 小傑（奇犽？)"></a>小結 || 小傑（奇犽？)</h2><hr><p>在有限的篇幅當中，我們嘗試去探討一個大方向的主題，物件導向在 <code>Ruby</code> 的世界中可能會是以怎樣的形式實作。這是一個可以用數千字到上萬字可能都還講不完的主題。但是筆者為什麼要選這樣的主題來分享呢？因為身為非本科生亂入變成每天和 <code>Ruby</code> &amp; <code>Rails</code> 打交道謀生的工作者，有一天因為工作上的需求去閱讀人生第一本原文書並把它看完了。從閱讀的過程中發現物件導向的觀念在同事幾年前所寫的龐大專案中無所不在。為什麼有經驗的 Coder 會用這種方式去寫程式呢？為什麼在 Code Review 的過程中會引導我嘗試去用物件導向的方式產出程式碼呢？這一切的一切都是從閱讀先前所推薦的物件導向書中慢慢理解。如果你和筆者一樣剛進入程式的世界還沒有很久，也許是時候擠出一點點的時間去閱讀一本關於物件導向的書籍。你也許會發現程式設計的美好世界（充滿 Bug 的世界？）最後請容許我引用一句講者在 <a href="https://2019.rubyconf.tw/">RubyConf Taiwan 2019</a> 閉幕演講的話做為結尾。</p><blockquote><p>Energy Saving &#x3D;&gt; Environent Friendly</p></blockquote><p>多利用物件導向，少複製貼上程式碼是可以節約能源拯救地球的！</p><blockquote><p>Let’s have this in mind and Build a Better World.</p></blockquote><p>讓我們謹記心，打造更棒的世界！</p><p><a href="https://speakerdeck.com/c9s/virtual-machines">演講投影片</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;還記得一開始自學程式語言時，大家一定或多或少都聽過一個名詞 &lt;code&gt;物件導向&lt;/code&gt;。然後身為程式新手和非程式相關科系畢業的你也許會開始 Google 它到底是什麼意思，然後你會在 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&quot;&gt;維基百科&lt;/a&gt; 上查到諸如此類的解釋：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;物件導向程式設計（英語：Object-oriented programming，縮寫：OOP）是種具有物件概念的程式編程典範，同時也是一種程式開發的抽象方針。它可能包含資料、屬性、程式碼與方法。物件則指的是類別的實體。它將物件作為程式的基本單元，將程式和資料封裝其中，以提高軟體的重用性、靈活性和擴充性，物件裡的程式可以存取及經常修改物件相關連的資料。在物件導向程式編程裡，電腦程式會被設計成彼此相關的物件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;當下看完名詞解釋，如果你和筆者一樣只是個普通人的話應該根據名詞解釋還是無法了解一個抽象的概念，然後可能因為你強盛的好奇心，會繼續在網路上搜尋更多的文章來理解這樣抽象的概念，但有可能你會發現閱讀更多文章後仍然似懂非懂，不要擔心這是屬於正常的現象。&lt;/p&gt;
&lt;h2 id=&quot;找到方向&quot;&gt;&lt;a href=&quot;#找到方向&quot; class=&quot;headerlink&quot; title=&quot;找到方向&quot;&gt;&lt;/a&gt;找到方向&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;上述所描寫的正是筆者個人學習上的經歷，看了些許文章後，仍然覺得少了點什麼才能對整體抽象的理論有更進一步的理解。直到閱讀了 &lt;code&gt;Practical Object-Oriented Design: An Agile Primer Using Ruby&lt;/code&gt; 才發現作者 &lt;a href=&quot;https://www.sandimetz.com/&quot;&gt;Sandi Metz&lt;/a&gt; 很懂得如何引導新手走入物件導向的大門。例如談論到物件導向時一定會提到的幾個重要原則：&lt;code&gt;SOLID&lt;/code&gt;（&lt;code&gt;單一功能&lt;/code&gt;、&lt;code&gt;開閉原則&lt;/code&gt;、&lt;code&gt;李氏替換&lt;/code&gt;、&lt;code&gt;介面隔離&lt;/code&gt;、&lt;code&gt;依賴反轉&lt;/code&gt;）當你看過這些原則後對於實際開發上該怎麼應用上，根據筆者個人的學習經驗似乎只會產生更多的疑問。但作者似乎知道與其講那些理論，不如透過探討實際的程式碼由淺入深的方式一步一步告訴你如果同樣的程式碼，採用物件導向的方式撰寫程式碼會有什麼優缺點？如果不使用物件導向的方式去寫可能會造成後續維護程式碼上困難？筆者看完那本書後終於對物件導向有了更深一層的概念，它也提供了思考程式碼「為什麼要這樣寫會更好？」的方向，而不僅僅是停在「把程式碼寫出來會動就好⋯⋯」的層面上。&lt;/p&gt;
&lt;p&gt;接下來將分享書中部分的概念，去探討如何運用技巧去撰寫出容易維護的程式碼。&lt;/p&gt;
&lt;h2 id=&quot;管理相依性-Manage-Dependencies&quot;&gt;&lt;a href=&quot;#管理相依性-Manage-Dependencies&quot; class=&quot;headerlink&quot; title=&quot;管理相依性 Manage Dependencies&quot;&gt;&lt;/a&gt;管理相依性 Manage Dependencies&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在物件導向的程式世界中，物件會有所謂 &lt;code&gt;相依性&lt;/code&gt; 的問題，什麼是相依性呢？我們舉現實生活中的車子來理解這個抽象概念。車子是一種交通工具對吧？在 &lt;code&gt;Ruby&lt;/code&gt; 中車子將可能會是車子這個類別中的一個實體物件，它的行為是進行移動。那車子為什麼可以移動的呢？車子是需要靠輪子來移動的，我們也可以說車子依賴輪子來進行移動，沒有輪子的車子可能哪也去不了，所以車子對輪子產生了很高的相依性。&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby On Rails 菜鳥的逆襲" scheme="https://blog.raiden.me/categories/Ruby-On-Rails-%E8%8F%9C%E9%B3%A5%E7%9A%84%E9%80%86%E8%A5%B2/"/>
    
    
    <category term="Ruby" scheme="https://blog.raiden.me/tags/Ruby/"/>
    
    <category term="Object-Oriented" scheme="https://blog.raiden.me/tags/Object-Oriented/"/>
    
    <category term="物件導向" scheme="https://blog.raiden.me/tags/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>使用 Ruby 製作屬於你的 Discord 聊天機器人</title>
    <link href="https://blog.raiden.me/2019/03/17/make-your-discord-chatbot-with-ruby/"/>
    <id>https://blog.raiden.me/2019/03/17/make-your-discord-chatbot-with-ruby/</id>
    <published>2019-03-17T07:52:05.000Z</published>
    <updated>2025-07-19T08:24:03.479Z</updated>
    
    <content type="html"><![CDATA[<p>最近很火紅的第一人稱射擊吃雞類型遊戲「Apex Legends」上市8小時內同時在線玩家人數突破100萬人（筆者也是其中之一），這款遊戲和 Ruby 能擦出什麼樣的火花呢？在本文中我們將嘗試使用 Ruby 搭配玩家間熱門的語音通訊社群軟體 Discord 製作聊天機器人再透過 API 獲取玩家於遊戲中的相關戰績資訊。該透過哪些步驟快速製作我們的聊天機器人呢？讓我們接下去看看吧！</p><h2 id="前置作業"><a href="#前置作業" class="headerlink" title="前置作業"></a>前置作業</h2><hr><p>假設你已經安裝好了程式語言 <code>Ruby</code>(如果沒有安裝的請到<a href="https://www.ruby-lang.org/zh_tw/downloads/">官方網站</a>根據自己所使用的 <code>OS</code> 安裝 <code>Ruby</code>)</p><p>然後我們需要建立一個 <code>Ruby</code> 檔案，在本文中我們建立一個名為  <code>chatbot.rb</code> 的檔案在資料夾 <code>discord</code> 下，其中副檔名為 <code>.rb</code> 代表這是一個 <code>Ruby</code> 的檔案。</p><p>接下來透過<a href="https://gitbook.tw/chapters/command-line/command-line.html">終端機</a>(何謂終端機可以參考連接文章的前面部份)進入 <code>chatbot.rb</code> 所在的資料夾中並輸入 <code>gem install bundler</code> 透過 <code>Ruby</code> 的套件管理工具 <code>Gem</code> 來安裝相依性套件版本管理工具 <a href="https://bundler.io/">Bundler</a> 後再輸入指令 <code>bundle init</code> 來初始化 <code>Bundler</code> 的相關資料。完成後會自動建立一個檔名為 <code>Gemfile</code> 的檔案，這個檔案是用來指定 <code>Ruby</code> 專案所使用 <code>Gem</code> 相關套件的設定檔。我們在 <code>Gemfile</code> 檔案中的最下方添加一行設定：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 你的 Ruby 專案資料夾下/Gemfile</span></span><br><span class="line"><span class="comment"># (其他 gem...)</span></span><br><span class="line">gem <span class="string">&quot;discordrb&quot;</span></span><br></pre></td></tr></table></figure><p>然後透過終端機輸入命令 <code>bundle install</code> 就會自動幫我們安裝別人打包好的 <code>Discord</code> 機器人函式庫 <a href="https://github.com/meew0/discordrb">discordrb</a>。</p><h3 id="獲得-Discord-Bot-Token"><a href="#獲得-Discord-Bot-Token" class="headerlink" title="獲得 Discord Bot Token"></a>獲得 Discord Bot Token</h3><p>要製作 <code>Discord Bot</code> 需要先獲得機器人的 <code>Token</code>，需要在 <a href="https://discordapp.com/developers/applications/">Discord Developer Portal</a> 申請一組帳號和在帳號下新增一個應用程式，並在 Bot 頁面生成一組 Token。如下圖範例位置：</p><p><img src="https://imgur.com/UE6JRfo.png" alt="chatbot_token"></p><h2 id="製作測試聊天機器人"><a href="#製作測試聊天機器人" class="headerlink" title="製作測試聊天機器人"></a>製作測試聊天機器人</h2><hr><p>成功註冊帳號並獲得 <code>Token</code> 後我們要開始撰寫聊天機器人的程式碼囉，利用文字編輯器編輯前面所建立的 <code>.rb</code> 檔案並新增下列程式碼：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 調用在 Gemfile 設定並安裝的 disocrd API 函式庫</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;discordrb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 將你在 Discord 申請的機器人 Token 帶入並實例化機器人</span></span><br><span class="line"><span class="comment"># 記得替換 Bot Token 為你自己的 Bot Token</span></span><br><span class="line">bot = <span class="title class_">Discordrb::Bot</span>.new <span class="symbol">token:</span> <span class="string">&#x27;你的 Bot Token&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Discord 頻道中對機器人說話後機器人會回應的行為設定</span></span><br><span class="line"><span class="comment"># 下方程式碼中 content: &#x27;Ping&#x27; 就是代表聊天室收到信息內容為 Ping! 時</span></span><br><span class="line"><span class="comment"># 會觸發事件並產生回覆內容 Pong!</span></span><br><span class="line">bot.message(<span class="symbol">content:</span> <span class="string">&#x27;Ping!&#x27;</span>) <span class="keyword">do</span> |<span class="params">event</span>|</span><br><span class="line">  event.respond <span class="string">&#x27;Pong!&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 運行機器人</span></span><br><span class="line">bot.run</span><br></pre></td></tr></table></figure><p>將檔案編輯完成後透過終端機輸入指令 <code>ruby discord.rb</code> 執行剛剛撰寫的機器人測試 <code>Ruby</code> 檔案。接下來根據官方的文件說明我們要邀請聊天機器人到你所屬的 <code>Discord</code> 聊天頻道中，可以透過一組網址為： <code>https://discordapp.com/oauth2/authorize?&amp;client_id=你的機器人_Client_ID&amp;scope=bot&amp;permissions=0</code></p><p>其中 <code>你的_Client_ID</code> 的部分請替換成 Discord Application 中的 Client ID 如下圖範例所在位置：</p><p><img src="https://imgur.com/1AEoD3q.png" alt="chatbot_client_id"></p><p>在瀏覽器輸入網址後我們會被導引到一個 <code>Discord</code> App 授權的畫面，當授權成功後我們就可以將機器人加入自己的 Discord Server 後在聊天頻道中輸入信息 <code>Ping!</code> 後如果有收到機器人回覆 <code>Pong!</code> 恭喜你機器人到目前為止算是成功設置了！</p><h2 id="將機器人串接-Apex-Legends-API"><a href="#將機器人串接-Apex-Legends-API" class="headerlink" title="將機器人串接 Apex Legends API"></a>將機器人串接 Apex Legends API</h2><hr><p>確認機器人可以正常建立並執行後，下一步我們要來串接 Apex Legends API 將現在只會簡單回應的機器人升級為可以透過關鍵字查詢遊戲戰績的機器人喔！</p><h3 id="註冊-TRN-Apex-Legends-API-帳號"><a href="#註冊-TRN-Apex-Legends-API-帳號" class="headerlink" title="註冊 TRN Apex Legends API 帳號"></a>註冊 TRN Apex Legends API 帳號</h3><p>本文中使用第三方服務 TRN Apex Legends Tracker API 來獲取角色戰績，所以需要先前往 <a href="https://apex.tracker.gg/site-api">TRN 官網</a> 頁面註冊帳號並申請 API KEY 並在附在 request header 透過 <code>Ruby</code> 發送 API request 時獲得授權才能取得我們想要的資料。</p><h3 id="調整機器人程式碼"><a href="#調整機器人程式碼" class="headerlink" title="調整機器人程式碼"></a>調整機器人程式碼</h3><p>在剛剛測試機器人的檔案 <code>discord.rb</code> 中我們實做了簡單的關鍵字回答功能，現在我們要利用註冊後取得的 API Key 對 TRN Apex Legends API 端點發送請求。請把檔案中的程式碼調整為以下範例。並替換 其中的 chatbot token 和 api key 為官網中註冊後所取得的 key。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 調用 Discord API 函式庫</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;discordrb&#x27;</span></span><br><span class="line"><span class="comment"># 宣告一個時間變數儲存呼叫 API 的時間</span></span><br><span class="line"><span class="variable">@call_time_last</span> = <span class="title class_">Time</span>.new</span><br><span class="line"></span><br><span class="line"><span class="comment"># 創建 Discord Bot 並帶入 Token 並將機器人命令附加前綴詞&#x27;!&#x27;</span></span><br><span class="line">bot = <span class="title class_">Discordrb::Commands::CommandBot</span>.new <span class="symbol">token:</span> <span class="string">&#x27;你的_chatbot_token&#x27;</span>, <span class="symbol">prefix:</span> <span class="string">&#x27;!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 為機器人定義指令 myhero 並處理 Apex Legends API 資料接收與解析</span></span><br><span class="line">bot.command <span class="symbol">:myhero</span> <span class="keyword">do</span> |<span class="params">event, player</span>|</span><br><span class="line">  <span class="comment"># 建立 Api 觸發時間，防止 call rate 超過 API 伺服器限制會有被禁止連線的問題</span></span><br><span class="line">  <span class="variable">@call_time_now</span> = <span class="title class_">Time</span>.now</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 當機器人收到指令 !myhero 玩家_ID 時將 ID 存入變數 player_name 中</span></span><br><span class="line">  <span class="variable">@player_name</span> = player</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 將我們要對 API 發送請求的網址存入變數中，並帶入玩家的 ID</span></span><br><span class="line">  uri = <span class="variable constant_">URI</span>(<span class="string">&quot;https://public-api.tracker.gg/apex/v1/standard/profile/5/<span class="subst">#&#123;<span class="variable">@player_name</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果這次呼叫 API 的時間距離上一次呼叫的時間經過兩秒半，正常呼叫 API。</span></span><br><span class="line">  <span class="keyword">if</span> <span class="variable">@call_time_now</span> - <span class="variable">@call_time_last</span> &gt; <span class="number">2.5</span></span><br><span class="line">    <span class="comment"># 紀錄成功呼叫 API 的時間</span></span><br><span class="line">    <span class="variable">@call_time_last</span> = <span class="title class_">Time</span>.now</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 Ruby 的 Net::HTTP 模組處理對 API 發出的 request</span></span><br><span class="line">    <span class="title class_">Net</span><span class="symbol">:</span><span class="symbol">:HTTP</span>.start(uri.host, uri.port, <span class="symbol">use_ssl:</span> <span class="literal">true</span>) <span class="keyword">do</span> |<span class="params">http</span>|</span><br><span class="line">      req = <span class="title class_">Net::HTTP::Get</span>.new(uri)</span><br><span class="line">      <span class="comment"># 將 TRN 申請的 Api Key 帶入 request header 中提供給 API 端點驗證</span></span><br><span class="line">      req[<span class="string">&#x27;TRN-Api-Key&#x27;</span>] = <span class="string">&#x27;在 TRN 取得的 api key&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 將發送 request 後得到的資料解析成 Json 格式</span></span><br><span class="line">      response = http.request(req)</span><br><span class="line">      <span class="variable">@data</span> = <span class="variable constant_">JSON</span>.parse(response.body)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 從 API 拿到的資料解析完後使用 event.respond 方法讓機器人在聊天室回應信息</span></span><br><span class="line">    event.respond <span class="string">&quot;</span></span><br><span class="line"><span class="string">    <span class="subst">#&#123;<span class="variable">@data</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;children&#x27;</span>].first[<span class="string">&#x27;metadata&#x27;</span>][<span class="string">&#x27;icon&#x27;</span>]&#125;</span></span></span><br><span class="line"><span class="string">    等級 (Level)：<span class="subst">#&#123;<span class="variable">@data</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;stats&#x27;</span>].first[<span class="string">&#x27;displayValue&#x27;</span>]&#125;</span></span></span><br><span class="line"><span class="string">    使用英雄 (Legend Name)：<span class="subst">#&#123;<span class="variable">@data</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;children&#x27;</span>].first[<span class="string">&#x27;metadata&#x27;</span>][<span class="string">&#x27;legend_name&#x27;</span>]&#125;</span></span></span><br><span class="line"><span class="string">    擊殺數 (<span class="subst">#&#123;<span class="variable">@data</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;children&#x27;</span>].first[<span class="string">&#x27;stats&#x27;</span>].first[<span class="string">&#x27;metadata&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]&#125;</span>)：<span class="subst">#&#123;<span class="variable">@data</span>[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;children&#x27;</span>].first[<span class="string">&#x27;stats&#x27;</span>].first[<span class="string">&#x27;displayValue&#x27;</span>]&#125;</span></span></span><br><span class="line"><span class="string">    &quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment"># 如果距離上次呼叫 API 所經過時間小於三秒，則顯示忙碌信息。</span></span><br><span class="line">    event.respond <span class="string">&quot;目前忙碌中，請稍待片刻再呼喚我...&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 run 方法讓機器人運行</span></span><br><span class="line">bot.run</span><br></pre></td></tr></table></figure><h3 id="測試機器人是否正常回應"><a href="#測試機器人是否正常回應" class="headerlink" title="測試機器人是否正常回應"></a>測試機器人是否正常回應</h3><p>調整程式碼後透過終端機再次輸入 <code>ruby discord.rb</code> 讓 <code>Ruby</code> 執行我們撰寫好的機器人檔案，接著到聊天機器人所在的 <code>Discord</code> 伺服器中輸入 <code>!myhero 遊戲ID</code> 會發現機器人自動回覆該玩家在遊戲中使用的角色圖片、帳號等級、擊殺數。如下圖範例：</p><p><img src="https://i.imgur.com/GTWGJkE.gif" alt="discord_chatbot_demo"></p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><hr><p>在本文中我們透過 <code>Ruby</code> 內建強大的套件工具 <code>Gem</code> 來安裝 <code>Discord</code> 機器人函式庫並撰寫程式碼製作簡易的聊天機器人。接下來串接第三方 API 讓機器人可以接收到 <code>Discord</code> 信息的關鍵字後透過呼叫第三方 API 端點獲取遊戲的相關資料並在聊天室中產生回應。這樣的流程下我們動手製作了屬於自己的聊天機器人，讓聊天室的戰友們可以快速獲得遊戲資訊，是不是一種 <code>Ruby</code> 很有趣又實用的應用呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近很火紅的第一人稱射擊吃雞類型遊戲「Apex Legends」上市8小時內同時在線玩家人數突破100萬人（筆者也是其中之一），這款遊戲和 Ruby 能擦出什麼樣的火花呢？在本文中我們將嘗試使用 Ruby 搭配玩家間熱門的語音通訊社群軟體 Discord 製作聊天機器人再透過 API 獲取玩家於遊戲中的相關戰績資訊。該透過哪些步驟快速製作我們的聊天機器人呢？讓我們接下去看看吧！&lt;/p&gt;
&lt;h2 id=&quot;前置作業&quot;&gt;&lt;a href=&quot;#前置作業&quot; class=&quot;headerlink&quot; title=&quot;前置作業&quot;&gt;&lt;/a&gt;前置作業&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;假設你已經安裝好了程式語言 &lt;code&gt;Ruby&lt;/code&gt;(如果沒有安裝的請到&lt;a href=&quot;https://www.ruby-lang.org/zh_tw/downloads/&quot;&gt;官方網站&lt;/a&gt;根據自己所使用的 &lt;code&gt;OS&lt;/code&gt; 安裝 &lt;code&gt;Ruby&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;然後我們需要建立一個 &lt;code&gt;Ruby&lt;/code&gt; 檔案，在本文中我們建立一個名為  &lt;code&gt;chatbot.rb&lt;/code&gt; 的檔案在資料夾 &lt;code&gt;discord&lt;/code&gt; 下，其中副檔名為 &lt;code&gt;.rb&lt;/code&gt; 代表這是一個 &lt;code&gt;Ruby&lt;/code&gt; 的檔案。&lt;/p&gt;
&lt;p&gt;接下來透過&lt;a href=&quot;https://gitbook.tw/chapters/command-line/command-line.html&quot;&gt;終端機&lt;/a&gt;(何謂終端機可以參考連接文章的前面部份)進入 &lt;code&gt;chatbot.rb&lt;/code&gt; 所在的資料夾中並輸入 &lt;code&gt;gem install bundler&lt;/code&gt; 透過 &lt;code&gt;Ruby&lt;/code&gt; 的套件管理工具 &lt;code&gt;Gem&lt;/code&gt; 來安裝相依性套件版本管理工具 &lt;a href=&quot;https://bundler.io/&quot;&gt;Bundler&lt;/a&gt; 後再輸入指令 &lt;code&gt;bundle init&lt;/code&gt; 來初始化 &lt;code&gt;Bundler&lt;/code&gt; 的相關資料。完成後會自動建立一個檔名為 &lt;code&gt;Gemfile&lt;/code&gt; 的檔案，這個檔案是用來指定 &lt;code&gt;Ruby&lt;/code&gt; 專案所使用 &lt;code&gt;Gem&lt;/code&gt; 相關套件的設定檔。我們在 &lt;code&gt;Gemfile&lt;/code&gt; 檔案中的最下方添加一行設定：&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 你的 Ruby 專案資料夾下/Gemfile&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# (其他 gem...)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gem &lt;span class=&quot;string&quot;&gt;&amp;quot;discordrb&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然後透過終端機輸入命令 &lt;code&gt;bundle install&lt;/code&gt; 就會自動幫我們安裝別人打包好的 &lt;code&gt;Discord&lt;/code&gt; 機器人函式庫 &lt;a href=&quot;https://github.com/meew0/discordrb&quot;&gt;discordrb&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;獲得-Discord-Bot-Token&quot;&gt;&lt;a href=&quot;#獲得-Discord-Bot-Token&quot; class=&quot;headerlink&quot; title=&quot;獲得 Discord Bot Token&quot;&gt;&lt;/a&gt;獲得 Discord Bot Token&lt;/h3&gt;&lt;p&gt;要製作 &lt;code&gt;Discord Bot&lt;/code&gt; 需要先獲得機器人的 &lt;code&gt;Token&lt;/code&gt;，需要在 &lt;a href=&quot;https://discordapp.com/developers/applications/&quot;&gt;Discord Developer Portal&lt;/a&gt; 申請一組帳號和在帳號下新增一個應用程式，並在 Bot 頁面生成一組 Token。如下圖範例位置：&lt;/p&gt;</summary>
    
    
    
    <category term="怪奇專案集散地" scheme="https://blog.raiden.me/categories/%E6%80%AA%E5%A5%87%E5%B0%88%E6%A1%88%E9%9B%86%E6%95%A3%E5%9C%B0/"/>
    
    
    <category term="Ruby" scheme="https://blog.raiden.me/tags/Ruby/"/>
    
    <category term="Chatbot" scheme="https://blog.raiden.me/tags/Chatbot/"/>
    
  </entry>
  
  <entry>
    <title>使用 rbenv 管理 Ruby 版本</title>
    <link href="https://blog.raiden.me/2019/02/18/manage-ruby-versions-with-rbenv/"/>
    <id>https://blog.raiden.me/2019/02/18/manage-ruby-versions-with-rbenv/</id>
    <published>2019-02-18T07:37:07.000Z</published>
    <updated>2021-03-15T03:48:44.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="關於菜鳥的逆襲"><a href="#關於菜鳥的逆襲" class="headerlink" title="關於菜鳥的逆襲"></a>關於菜鳥的逆襲</h1><hr><p>想撰寫此系列文章的動機在於筆者剛開始學習 <code>Ruby On Rails</code> 的過程中，由於對程式背景相關知識的不足，導致產生大量撞牆時間。在頭破血流的過程中，將盡量紀錄對於新手時期可能會遇到的問題與解法，期望能幫助到有緣人在學習 <code>Ruby On Rails</code> 路上避開可能會踩到的各種坑。</p><h1 id="為什麼需要-rbenv"><a href="#為什麼需要-rbenv" class="headerlink" title="為什麼需要 rbenv ?"></a>為什麼需要 rbenv ?</h1><hr><p><code>rbenv</code> 是一種版本控管工具，被用來安裝與管理你所使用的 <code>Ruby</code> 版本。為什麼需要管理 <code>Ruby</code> 版本呢？</p><p>由於一般在使用 <code>Ruby On Rails</code> 開發專案的過程中，你將有很高的機率面臨需要切換不同版本 <code>Ruby</code> 的情境，因為每個專案可能使用的 <code>Ruby</code> 版本都不盡相同，且專案中所使用的 <code>Gem</code> 也是基於某個 <code>Ruby</code> 版本下去寫的，這導致了有些你想用的 <code>Gem</code> 可能只支援某個版本以前或以後的 <code>Ruby</code>，而你想用這些 <code>Gem</code> 就必須搭配支援的 <code>Ruby</code> 版本。所以學會使 <code>Ruby</code> 版本控管工具來切換不同的 <code>Ruby</code> 版本就顯得很重要。</p><h1 id="安裝-rbenv"><a href="#安裝-rbenv" class="headerlink" title="安裝 rbenv"></a>安裝 rbenv</h1><hr><p>由於筆者所使用的作業系統是 <code>macOS</code>，所以我們將介紹如何在 <code>Mac</code> 的環境下透過 <code>Homebrew</code> 安裝 <code>rbenv</code>。如果你所使用的作業系統是 <code>Windows</code> 可以參考 <a href="https://docs.brew.sh/Homebrew-on-Linux">這裡</a>。</p><h2 id="安裝-Homebrew"><a href="#安裝-Homebrew" class="headerlink" title="安裝 Homebrew"></a>安裝 Homebrew</h2><p>在<a href="https://github.com/rbenv/rbenv">官方文件</a>中推薦使用 Homebrew 安裝 rbenv。Homebrew 也是一種軟體版本控管的工具，只要在命令列下簡單的指令就可以透過 Homebrew 安裝軟體到電腦上並管理，所以我們就開始安裝 Homebrew 吧。</p><p>首先到 Homebrew 的<a href="https://brew.sh/index_zh-tw">官方網站</a>可以看到安裝的指令非常簡單只需要在終端機輸入以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>待安裝指令跑完後便會在路徑 <code>/usr/local/bin</code> 中安裝好 Homebrew。</p><h2 id="透過-Homebrew-安裝-rbenv"><a href="#透過-Homebrew-安裝-rbenv" class="headerlink" title="透過 Homebrew 安裝 rbenv"></a>透過 Homebrew 安裝 rbenv</h2><p>我們可以透過以下指令來安裝 <code>rbenv</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install rbenv</span><br></pre></td></tr></table></figure><p>指令跑完後我們可以同樣在路徑 <code>/usr/local/bin</code> 中發現多了檔案 <code>rbenv</code> 就可以知道目前為止 <code>rvenv</code> 已經在我們電腦中了，接下來還要做一些設定來完成安裝。</p><h2 id="為-rbenv-設定環境變數"><a href="#為-rbenv-設定環境變數" class="headerlink" title="為 rbenv 設定環境變數"></a>為 rbenv 設定環境變數</h2><p>為麼要設定環境變數呢？當我們在終端機上輸入指令 <code>rbrnv</code> 時，電腦會需要透過一些路徑上的設定來搜索需要被執行的程式，簡單來說我們在終端機呼叫某個程式的時候要告訴終端機程式住在哪裡才能找到並且執行它的意思。</p><p>如果你使用的是 Mac 內建的終端機(bash)請在終端機中輸入下列指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure><p>如果你使用的是 <code>zsh</code> 那麼請改成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>上面這些指令的作用是在根目錄中的隱藏檔案 <code>.bash_profile</code> 或 <code>.zshrc</code> 中插入一行設定來使得我們安裝的 <code>rbenv</code> 路徑加入環境變數 <code>$PATH</code> 後再回傳整個環境變數設定。那個 <code>.bash_profile</code> 檔案是做什麼用的？這個檔案就是每當你開器終端機時都會去讀取的一個設定檔，所以當我們把 <code>rbenv</code> 設定檔加入之後每次開起終端機後都會幫我們把執行 <code>rbenv</code> 指令要搜索 <code>rbenv</code> 程式本體所在的目錄路徑加到環境變數 <code>$PATH</code> 中，這樣就可以確保我們執行的指令會正確的找到程式並執行。</p><p>在這邊屬於 Linux 作業系統的基礎知識，所以對於初學程式的人來說可能會一頭霧水，在還沒開始正式寫程式前就會先面臨到一堆開發環境設置的問題呢。</p><p>完成上述設定後還要輸入下列設定來進行 <code>rbenv</code> 安裝完成後的初始化工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.rbenv/bin/rbenv init</span><br></pre></td></tr></table></figure><p>指令執行完畢後你可以選擇關閉現在的終端機視窗，再開啟一個全新的終端機視窗，此時你應開會發現在終端機中輸入 <code>rbenv</code> 可以正常作用了。</p><h1 id="基本的-rbenv-指令"><a href="#基本的-rbenv-指令" class="headerlink" title="基本的 rbenv 指令"></a>基本的 rbenv 指令</h1><hr><h2 id="透過-rbenv-安裝-Ruby"><a href="#透過-rbenv-安裝-Ruby" class="headerlink" title="透過 rbenv 安裝 Ruby"></a>透過 rbenv 安裝 Ruby</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbenv install -l</span><br></pre></td></tr></table></figure><p>上列指令可以列出目前可以安裝的 Ruby 版本，確認想要安裝的 Ruby 版本後再透過指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbenv install 你想要的版本</span><br></pre></td></tr></table></figure><p>就可以安裝你選擇的 Ruby 版本了。</p><h2 id="切換使用的-Ruby-版本"><a href="#切換使用的-Ruby-版本" class="headerlink" title="切換使用的 Ruby 版本"></a>切換使用的 Ruby 版本</h2><p>要切換使用的 Ruby 版本我們可以透過輸入兩個指令來切換使用的 Ruby 版本，分別是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbenv global 版本號碼</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rbenv <span class="built_in">local</span> 版本號碼</span><br></pre></td></tr></table></figure><p>這兩個指令的差別在於帶有 <code>local</code> 的指令通常在專案的目錄底下執行，因為指令執行後會在該專案的目錄下留下一個隱藏檔案來記錄當我們在這個目錄中所使用的 Ruby 版號，且僅在這個目錄下有效。如果你是在其他的地方使用 Ruby 那我們所使用的版本就會是帶有 <code>global</code> 指令所設定的 Ruby 版本。</p><h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><hr><p>在進行撰寫程式碼之前的課題就是建置環境，當時因為對 Linux 連最基礎的知識都沒有所以在這邊卡了非常久，希望這篇文章的分享有機會幫助到和我一樣缺乏 Linux 基礎背景知識又卡關的苦主，希望大家日後都可以順利的完成開發環境建置工作喔！</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;關於菜鳥的逆襲&quot;&gt;&lt;a href=&quot;#關於菜鳥的逆襲&quot; class=&quot;headerlink&quot; title=&quot;關於菜鳥的逆襲&quot;&gt;&lt;/a&gt;關於菜鳥的逆襲&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;想撰寫此系列文章的動機在於筆者剛開始學習 &lt;code&gt;Ruby On Rails&lt;/code&gt; 的過程中，由於對程式背景相關知識的不足，導致產生大量撞牆時間。在頭破血流的過程中，將盡量紀錄對於新手時期可能會遇到的問題與解法，期望能幫助到有緣人在學習 &lt;code&gt;Ruby On Rails&lt;/code&gt; 路上避開可能會踩到的各種坑。&lt;/p&gt;
&lt;h1 id=&quot;為什麼需要-rbenv&quot;&gt;&lt;a href=&quot;#為什麼需要-rbenv&quot; class=&quot;headerlink&quot; title=&quot;為什麼需要 rbenv ?&quot;&gt;&lt;/a&gt;為什麼需要 rbenv ?&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;rbenv&lt;/code&gt; 是一種版本控管工具，被用來安裝與管理你所使用的 &lt;code&gt;Ruby&lt;/code&gt; 版本。為什麼需要管理 &lt;code&gt;Ruby&lt;/code&gt; 版本呢？&lt;/p&gt;
&lt;p&gt;由於一般在使用 &lt;code&gt;Ruby On Rails&lt;/code&gt; 開發專案的過程中，你將有很高的機率面臨需要切換不同版本 &lt;code&gt;Ruby&lt;/code&gt; 的情境，因為每個專案可能使用的 &lt;code&gt;Ruby&lt;/code&gt; 版本都不盡相同，且專案中所使用的 &lt;code&gt;Gem&lt;/code&gt; 也是基於某個 &lt;code&gt;Ruby&lt;/code&gt; 版本下去寫的，這導致了有些你想用的 &lt;code&gt;Gem&lt;/code&gt; 可能只支援某個版本以前或以後的 &lt;code&gt;Ruby&lt;/code&gt;，而你想用這些 &lt;code&gt;Gem&lt;/code&gt; 就必須搭配支援的 &lt;code&gt;Ruby&lt;/code&gt; 版本。所以學會使 &lt;code&gt;Ruby&lt;/code&gt; 版本控管工具來切換不同的 &lt;code&gt;Ruby&lt;/code&gt; 版本就顯得很重要。&lt;/p&gt;
&lt;h1 id=&quot;安裝-rbenv&quot;&gt;&lt;a href=&quot;#安裝-rbenv&quot; class=&quot;headerlink&quot; title=&quot;安裝 rbenv&quot;&gt;&lt;/a&gt;安裝 rbenv&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;由於筆者所使用的作業系統是 &lt;code&gt;macOS&lt;/code&gt;，所以我們將介紹如何在 &lt;code&gt;Mac&lt;/code&gt; 的環境下透過 &lt;code&gt;Homebrew&lt;/code&gt; 安裝 &lt;code&gt;rbenv&lt;/code&gt;。如果你所使用的作業系統是 &lt;code&gt;Windows&lt;/code&gt; 可以參考 &lt;a href=&quot;https://docs.brew.sh/Homebrew-on-Linux&quot;&gt;這裡&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Ruby On Rails 菜鳥的逆襲" scheme="https://blog.raiden.me/categories/Ruby-On-Rails-%E8%8F%9C%E9%B3%A5%E7%9A%84%E9%80%86%E8%A5%B2/"/>
    
    
    <category term="Ruby On Rails" scheme="https://blog.raiden.me/tags/Ruby-On-Rails/"/>
    
    <category term="Developer Tools" scheme="https://blog.raiden.me/tags/Developer-Tools/"/>
    
  </entry>
  
</feed>
